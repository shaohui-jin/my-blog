import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,o as n,c as a,a as t,e as i,w as d,b as s,d as e}from"./app-EVybbKqM.js";const c={},h=s('<h3 id="ajax" tabindex="-1"><a class="header-anchor" href="#ajax"><span>ajax</span></a></h3><ul><li>「<strong>AJAX 全称 Asynchronous Javascript And XML</strong>」：异步JavaScript和xml，是一种技术的统称 <ul><li>「<strong>XHR 全称 XmlHttpRequest</strong>」：HTML源生实现Ajax的一种技术</li><li>「<strong>Fetch</strong>」：基于 Promise 的一种api，在es6时提出，用于代替 XHR 实现 AJAX 的一种技术</li></ul></li><li>「<strong>axios</strong>」 是一种 使用 Promise + xhr 封装的第三方库</li><li>「<strong>umi-request</strong>」： 基于 fetch 封装的第三方库</li></ul><blockquote><p><strong>上传下载进度：</strong></p><ol><li>xhr <code>支持上传、下载进度展示</code></li><li>fetch 不支持上传进度，<code>支持下载进度展示</code></li></ol><p><strong>Abort 取消机制：</strong></p><ol><li>xhr <code>支持终止请求</code></li><li>fetch <code>本身不支持</code>，可使用 <code>信号控制器 AbortController</code> 实现</li></ol><p><strong>Timeout 超时机制:</strong></p><ol><li>xhr <code>支持超时机制</code></li><li>fetch <strong>本身不支持</strong>，可使用 <code>信号控制器 AbortController</code> 以及 <code>Promise</code> 实现</li></ol></blockquote><h3 id="地址栏输入url按下回车会发生什么事" tabindex="-1"><a class="header-anchor" href="#地址栏输入url按下回车会发生什么事"><span>地址栏输入url按下回车会发生什么事</span></a></h3><blockquote><ol><li><strong>url检测</strong>：<code>检查</code>/<code>纠错</code></li><li><strong>Dns解析</strong></li><li><strong>TCP三次握手</strong>(SSL握手)</li><li>准备请求(请求头： cookies + ...)</li><li><strong>发送请求</strong>(GET)</li><li>服务器处理请求</li><li><strong>服务器响应</strong></li><li>浏览器收到响应头</li><li>处理响应头(<code>set-cookie</code>、<code>content-type</code>、<code>缓存</code>、<code>状态码</code>、<code>connection: keep-alive</code>)</li><li>收响应体</li><li><strong>渲染</strong><ul><li>解析(预处理线程，资源加载、资源描述符 async defer preload prefetch) 生成DOM树和CSSOM树</li><li>样式计算</li><li>Layout布局</li><li>layer 分层</li><li>paint 绘制(主线程结束、合成线程开始)</li><li>tiles 分块</li><li>光栅化</li><li>draw 画</li></ul></li><li><strong>根据情况是否需要关闭连接，四次挥手</strong></li></ol></blockquote><h3 id="preload、prefetch、async、defer的区别" tabindex="-1"><a class="header-anchor" href="#preload、prefetch、async、defer的区别"><span>preload、prefetch、async、defer的区别</span></a></h3><blockquote><p>preload 和 prefetch：用于资源提前加载，分别适用当前页面和未来可能需要的资源。</p><ul><li><strong>Preload</strong>：用于告诉浏览器在页面加载过程中需要高优先级加载的资源。</li><li><strong>Prefetch</strong>：用于告诉浏览器资源之后可能会在未来使用，因此可以在空闲时间提前下载。</li></ul><p><strong>async</strong> 和 <strong>defer</strong>：用于控制脚本的加载与执行时机，async最适合独立脚本，defer适合需要按顺序执行且依赖DOM的脚本。</p><ul><li><strong>Async</strong>：async用于异步加载JavaScript，脚本下载完成后立即执行，不会影响dom脚本解析。</li><li><strong>Defer</strong>：defer用于延迟执行JavaScript，直到HTML解析完毕之后再执行。</li></ul></blockquote><h3 id="async、defer、load、domcontentloaded-先后顺序" tabindex="-1"><a class="header-anchor" href="#async、defer、load、domcontentloaded-先后顺序"><span>async、defer、load、DOMContentLoaded 先后顺序</span></a></h3><blockquote><p>defer -&gt; DOMContentLoaded -&gt; window.onload -&gt; load</p><p>async -&gt; window.onload -&gt; load</p></blockquote><ul><li><strong>DOMContentLoaded</strong> —— 浏览器已完全加载HTML，并构建了DOM树，但像<strong>img标签</strong>和<strong>样式表之类</strong>的外部资源可能尚未加载完成。</li><li><strong>load</strong> —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等</li><li><strong>async</strong> —— async脚本的加载是异步的，不会阻塞HTML解析。脚本一旦下载完成，会立即执行，此时可能会中断HTML解析（若解析尚未完成）。由于浏览器并行下载脚本和其他资源，因此其执行时机取决于下载完成的时间。</li><li><strong>window.onload</strong> —— window.onload事件会在页面所有资源（包括图片、样式表、异步脚本等）加载完成后触发。这意味着浏览器会等待async脚本的下载完成，即使它们的执行已经结束。</li></ul><h3 id="http-1-0-2-0-区别" tabindex="-1"><a class="header-anchor" href="#http-1-0-2-0-区别"><span>http 1.0 2.0 区别</span></a></h3><table><thead><tr><th></th><th>http 1.0</th><th>http 2.0</th></tr></thead><tbody><tr><td>连接方式</td><td>默认使用<code>短连接</code>，每个请求需要单独建立一次TCP连接，请求完成后立即关闭。会导致频繁的TCP握手和断开，增加了网络延迟和开销‌。</td><td>采用<code>长连接</code>，默认复用同一个TCP连接，可以在一个连接上并发处理多个请求和响应，减少了TCP连接的建立和断开次数，提高性能和效率‌‌。</td></tr><tr><td>数据格式</td><td>基于<code>文本</code>的协议，请求和响应以纯文本形式传输，解析效率低且容易出错‌。</td><td>采用<code>二进制分帧</code>，将数据分割为更小的二进制帧进行传输，提高了传输效率和错误率低‌。</td></tr><tr><td>头部压缩</td><td><code>不支持</code>头部压缩，每次请求需要重复发送完整的头部信息，浪费带宽‌</td><td>使用<code>HPACK算法</code>对头部进行压缩，减少了冗余数据传输，典型压缩率可达50%-90%。</td></tr><tr><td>‌多路复用‌</td><td><code>不支持</code>多路复用，请求需要按顺序发送和接收，存在“队头阻塞”问题</td><td><code>支持</code>多路复用，单个TCP连接可以并发处理多个请求和响应，解决了队头阻塞问题，提高了并发处理能力‌</td></tr><tr><td>服务器推送</td><td><code>不支持</code>服务器推送功能，客户端必须主动请求每个资源‌。</td><td>服务器可以<code>主动向客户端推送资源</code>。</td></tr></tbody></table>',12),p={id:"浏览器缓存-与-http缓存",tabindex:"-1"},g={class:"header-anchor",href:"#浏览器缓存-与-http缓存"},u=t("blockquote",null,[t("p",null,[t("code",null,"localStorage(5M)"),e("、"),t("code",null,"sessionStorage(5M)"),e("、"),t("code",null,"cookie(4k)")])],-1);function m(f,y){const o=r("RouteLink");return n(),a("div",null,[h,t("h3",p,[t("a",g,[t("span",null,[i(o,{to:"/Promotion/JavaScript/BrowserCache/"},{default:d(()=>[e("浏览器缓存 与 http缓存")]),_:1})])])]),u])}const _=l(c,[["render",m],["__file","网络.html.vue"]]),b=JSON.parse('{"path":"/zh/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BD%91%E7%BB%9C.html","title":"","lang":"zh-CN","frontmatter":{"headerDepth":3,"gitInclude":["../../../src/zh/精选文章/JavaScript/网络/AJAX - XHR与Fetch.md"],"description":"ajax 「AJAX 全称 Asynchronous Javascript And XML」：异步JavaScript和xml，是一种技术的统称 「XHR 全称 XmlHttpRequest」：HTML源生实现Ajax的一种技术 「Fetch」：基于 Promise 的一种api，在es6时提出，用于代替 XHR 实现 AJAX 的一种技术 「axio...","head":[["meta",{"property":"og:url","content":"https://shaohui-jin.github.io/my-blog/zh/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BD%91%E7%BB%9C.html"}],["meta",{"property":"og:description","content":"ajax 「AJAX 全称 Asynchronous Javascript And XML」：异步JavaScript和xml，是一种技术的统称 「XHR 全称 XmlHttpRequest」：HTML源生实现Ajax的一种技术 「Fetch」：基于 Promise 的一种api，在es6时提出，用于代替 XHR 实现 AJAX 的一种技术 「axio..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-16T08:15:52.000Z"}],["meta",{"property":"article:author","content":"石怜安"}],["meta",{"property":"article:modified_time","content":"2025-06-16T08:15:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-16T08:15:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"石怜安\\",\\"url\\":\\"https://shaohui-jin.github.io\\"}]}"]]},"headers":[{"level":3,"title":"ajax","slug":"ajax","link":"#ajax","children":[]},{"level":3,"title":"地址栏输入url按下回车会发生什么事","slug":"地址栏输入url按下回车会发生什么事","link":"#地址栏输入url按下回车会发生什么事","children":[]},{"level":3,"title":"preload、prefetch、async、defer的区别","slug":"preload、prefetch、async、defer的区别","link":"#preload、prefetch、async、defer的区别","children":[]},{"level":3,"title":"async、defer、load、DOMContentLoaded 先后顺序","slug":"async、defer、load、domcontentloaded-先后顺序","link":"#async、defer、load、domcontentloaded-先后顺序","children":[]},{"level":3,"title":"http 1.0 2.0 区别","slug":"http-1-0-2-0-区别","link":"#http-1-0-2-0-区别","children":[]},{"level":3,"title":"浏览器缓存 与 http缓存","slug":"浏览器缓存-与-http缓存","link":"#浏览器缓存-与-http缓存","children":[]}],"git":{"createdTime":1744883120000,"updatedTime":1750061752000,"contributors":[{"name":"shaohui_jin","email":"1051131737@qq.com","commits":3}]},"readingTime":{"minutes":3.32,"words":995},"filePathRelative":"zh/面试题/网络.md","localizedDate":"2025年4月17日","excerpt":"<h3>ajax</h3>\\n<ul>\\n<li>「<strong>AJAX 全称 Asynchronous Javascript And XML</strong>」：异步JavaScript和xml，是一种技术的统称\\n<ul>\\n<li>「<strong>XHR 全称 XmlHttpRequest</strong>」：HTML源生实现Ajax的一种技术</li>\\n<li>「<strong>Fetch</strong>」：基于 Promise 的一种api，在es6时提出，用于代替 XHR 实现 AJAX 的一种技术</li>\\n</ul>\\n</li>\\n<li>「<strong>axios</strong>」 是一种 使用 Promise + xhr 封装的第三方库</li>\\n<li>「<strong>umi-request</strong>」： 基于 fetch 封装的第三方库</li>\\n</ul>","autoDesc":true}');export{_ as comp,b as data};
