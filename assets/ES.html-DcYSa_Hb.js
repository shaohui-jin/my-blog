import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as e,b as a}from"./app-EVybbKqM.js";const l={},t=a(`<h3 id="es6新特性" tabindex="-1"><a class="header-anchor" href="#es6新特性"><span>ES6新特性</span></a></h3><ol><li>块级作用域（let const）</li></ol><blockquote><p>不存在变量提升、存在暂时性死区、块级作用域、不能在同一个作用域重复声明</p></blockquote><ol start="2"><li>新增语法糖 class</li><li>基本数据类型 symbol</li><li>新增解构赋值</li><li>新增箭头函数 不能作为构造函数使用，不能使用new、箭头函数没有原型、箭头函数没有arguments、箭头函数不能使用call、bind、apply改变this的指向、this指向 外层第一个函数的this</li><li>新增了函数参数的默认值</li><li>数组新增了api</li><li>对象数组新增了拓展运算符 console.log(1, ...[2, 3, 4], 5)</li><li>Promise</li><li>模块化 import export</li><li>新增set(不重复) map(key类型不受限制)数据结构</li><li>新增generator</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">xxfn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token string">&#39;d end...&#39;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> _xxfn <span class="token operator">=</span> <span class="token function">xxfn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//第一个yield语句</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_xxfn<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//{value: &#39;a&#39;, done: false}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h3><ol><li>原型链的继承</li></ol><p>让一个构造函数的原型是另一个类型的实例，那么这个构造函数new出来的实例就具有该实例的属性</p><p><code>优点</code>：写法方便简洁，容易理解</p><p><code>缺点</code>： 对象实例共享所有继承的属性和方法，无法向父类构造函数传值</p><ol start="2"><li>借用构造函数继承</li></ol><p>在子类型构造函数的内部调用父类型的构造函数，使用 apply或call将父对象的构造函数绑定在子对象上</p><p><code>优点</code>： 解决了原型链实现继承的不能传参的问题以及父类的原型共享问题</p><p><code>缺点</code>：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言是不可见的</p><ol start="3"><li>组合继承</li></ol><p>使用原型链实现对原型属性和方法的继承 通过借用构造函数进来实现对实例属性的继承 既通过在原型上定义方法，实现了函数复用，又能保证每个实例都有自己的属性</p><h3 id="es6-的-class" tabindex="-1"><a class="header-anchor" href="#es6-的-class"><span>Es6 的 class</span></a></h3><p>Class通过extends关键字来实现继承，其本质是</p><ol><li>先创造出父类的this对象</li><li>然后用子类的构造函数修改this</li><li>子类的构造函数中必须调用super方法，且只有在调用了super之后才能使用this，因为子类的this对象是继承父类的this对象，然后对其进行加工，而super方法表示的是父类的构造函数，用来新建父类的this对象</li></ol><h3 id="es6-的-promise" tabindex="-1"><a class="header-anchor" href="#es6-的-promise"><span>ES6 的 Promise</span></a></h3><ol><li>解决了回调地狱的问题</li><li>自身有all、reject、resolve、race方法</li><li>原型上有then、catch方法</li><li>把异步队列化</li><li>三种状态：pending 初始状态、rejected 操作失败、fulfilled 操作成功</li></ol>`,21),i=[t];function o(p,c){return n(),e("div",null,i)}const u=s(l,[["render",o],["__file","ES.html.vue"]]),h=JSON.parse('{"path":"/zh/%E9%9D%A2%E8%AF%95%E9%A2%98/ES.html","title":"","lang":"zh-CN","frontmatter":{"headerDepth":3,"description":"ES6新特性 块级作用域（let const） 不存在变量提升、存在暂时性死区、块级作用域、不能在同一个作用域重复声明 新增语法糖 class 基本数据类型 symbol 新增解构赋值 新增箭头函数 不能作为构造函数使用，不能使用new、箭头函数没有原型、箭头函数没有arguments、箭头函数不能使用call、bind、apply改变this的指向、...","head":[["meta",{"property":"og:url","content":"https://shaohui-jin.github.io/my-blog/zh/%E9%9D%A2%E8%AF%95%E9%A2%98/ES.html"}],["meta",{"property":"og:description","content":"ES6新特性 块级作用域（let const） 不存在变量提升、存在暂时性死区、块级作用域、不能在同一个作用域重复声明 新增语法糖 class 基本数据类型 symbol 新增解构赋值 新增箭头函数 不能作为构造函数使用，不能使用new、箭头函数没有原型、箭头函数没有arguments、箭头函数不能使用call、bind、apply改变this的指向、..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-22T12:43:16.000Z"}],["meta",{"property":"article:author","content":"石怜安"}],["meta",{"property":"article:modified_time","content":"2025-05-22T12:43:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-22T12:43:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"石怜安\\",\\"url\\":\\"https://shaohui-jin.github.io\\"}]}"]]},"headers":[{"level":3,"title":"ES6新特性","slug":"es6新特性","link":"#es6新特性","children":[]},{"level":3,"title":"继承","slug":"继承","link":"#继承","children":[]},{"level":3,"title":"Es6 的 class","slug":"es6-的-class","link":"#es6-的-class","children":[]},{"level":3,"title":"ES6 的 Promise","slug":"es6-的-promise","link":"#es6-的-promise","children":[]}],"git":{"createdTime":1747917796000,"updatedTime":1747917796000,"contributors":[{"name":"shaohui_jin","email":"1051131737@qq.com","commits":1}]},"readingTime":{"minutes":2.42,"words":725},"filePathRelative":"zh/面试题/ES.md","localizedDate":"2025年5月22日","excerpt":"<h3>ES6新特性</h3>\\n<ol>\\n<li>块级作用域（let const）</li>\\n</ol>\\n<blockquote>\\n<p>不存在变量提升、存在暂时性死区、块级作用域、不能在同一个作用域重复声明</p>\\n</blockquote>\\n<ol start=\\"2\\">\\n<li>新增语法糖 class</li>\\n<li>基本数据类型 symbol</li>\\n<li>新增解构赋值</li>\\n<li>新增箭头函数\\n不能作为构造函数使用，不能使用new、箭头函数没有原型、箭头函数没有arguments、箭头函数不能使用call、bind、apply改变this的指向、this指向 外层第一个函数的this</li>\\n<li>新增了函数参数的默认值</li>\\n<li>数组新增了api</li>\\n<li>对象数组新增了拓展运算符\\nconsole.log(1, ...[2, 3, 4], 5)</li>\\n<li>Promise</li>\\n<li>模块化 import export</li>\\n<li>新增set(不重复) map(key类型不受限制)数据结构</li>\\n<li>新增generator</li>\\n</ol>","autoDesc":true}');export{u as comp,h as data};
