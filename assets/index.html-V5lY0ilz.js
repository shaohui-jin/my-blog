import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as o,b as a}from"./app-wd9UAkBE.js";const n={},r=a('<h3 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h3><p><code>描述</code>： 函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包</p><p><code>特点</code>： 可以重复利用变量，并且这个变量不会污染全局；这个变量一直保存在内存中，不会被垃圾回收机制回收</p><p><code>缺点</code>： 闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露</p><p><code>使用</code>： 防抖，节流，函数嵌套函数避免全局污染</p><blockquote><p><strong>高级描述：</strong></p><ol><li><code>函数</code> + <code>其定义时所处的词法环境</code></li><li><code>函数本身</code> + <code>内部属性[Environment]</code></li></ol><p><strong>内存泄漏条件：</strong></p><ol><li><strong>持有了不再需要的函数引用，会导致函数关联的 <code>词法环境</code> 无法销毁，从而导致内存泄露</strong></li><li><strong>当多个函数 <code>共享词法环境</code> 时，会导致词法环境膨胀，从而导致出现 <code>无法触达</code> 也 <code>无法回收</code> 的内存空间，导致内存泄漏</strong></li></ol></blockquote><h3 id="ajax" tabindex="-1"><a class="header-anchor" href="#ajax"><span>ajax</span></a></h3><ul><li>「<strong>AJAX 全称 Asynchronous Javascript And XML</strong>」：异步JavaScript和xml，是一种技术的统称 <ul><li>「<strong>XHR 全称 XmlHttpRequest</strong>」：HTML源生实现Ajax的一种技术</li><li>「<strong>Fetch</strong>」：基于 Promise 的一种api，在es6时提出，用于代替 XHR 实现 AJAX 的一种技术</li></ul></li><li>「<strong>axios</strong>」 是一种 使用 Promise + xhr 封装的第三方库</li><li>「<strong>umi-request</strong>」： 基于 fetch 封装的第三方库</li></ul><blockquote><p><strong>上传下载进度：</strong></p><ol><li>xhr <code>支持上传、下载进度展示</code></li><li>fetch 不支持上传进度，<code>支持下载进度展示</code></li></ol><p><strong>Abort 取消机制：</strong></p><ol><li>xhr <code>支持终止请求</code></li><li>fetch <code>本身不支持</code>，可使用 <code>信号控制器 AbortController</code> 实现</li></ol><p><strong>Timeout 超时机制:</strong></p><ol><li>xhr <code>支持超时机制</code></li><li>fetch <strong>本身不支持</strong>，可使用 <code>信号控制器 AbortController</code> 以及 <code>Promise</code> 实现</li></ol></blockquote><h3 id="浏览器渲染原理" tabindex="-1"><a class="header-anchor" href="#浏览器渲染原理"><span>浏览器渲染原理</span></a></h3><p>整个渲染流程分为多个阶段，分别是： <code>HTML 解析</code>、<code>样式计算</code>、<code>布局</code>、<code>分层</code>、<code>绘制</code>、<code>分块</code>、<code>光栅化</code>、<code>画</code></p><p>每个阶段都有明确的输入输出，「<strong>上一个阶段的输出</strong>」 会成为 「<strong>下一个阶段的输入</strong>」。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><figure><img src="https://shaohui-jin.github.io/picx-images-hosting/blog/EventLoop/渲染流水线.41xtnyj74g.webp" alt="" width="800" tabindex="0" loading="lazy"><figcaption>渲染流水线</figcaption></figure><h3 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环"><span>事件循环</span></a></h3><p>事件循环又叫做消息循环，是浏览器 <strong>渲染主线程</strong> 的工作方式。</p><p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出 <strong>第一个任务</strong>执行，而其他线程只需要在合适的时候将任务加入到 <strong>队列末尾</strong> 即可。</p><p>过去把消息队列简单分为 <strong>宏队列</strong> 和 <strong>微队列</strong>，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据 W3C 官方的解释，每个任务有不同的类型，<strong>同类型的任务必须在同一个队列</strong>，<strong>不同的任务可以属于不同的队列</strong>。</p><p>不同任务队列有 <strong>不同的优先级</strong>，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。</p><p>但浏览器 <strong>必须</strong> 有一个<strong>微队列</strong>，微队列的任务一定具有 <strong>最高的优先级</strong>，必须优先调度执行。</p><h3 id="js-中的计时器能做到精确计时吗" tabindex="-1"><a class="header-anchor" href="#js-中的计时器能做到精确计时吗"><span>JS 中的计时器能做到精确计时吗</span></a></h3><p>不行，因为:</p><ol><li>计算机硬件没有 <strong><code>原子钟</code></strong>，无法做到精确计时</li><li>操作系统的计时函数本身就有少量偏差，<strong><code>由于 JS 的计时器最终调用的是操作系统的函数</code></strong>，也就携带了这些偏差</li><li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级 <strong><code>超过5层</code></strong>，则会带有 <strong><code>4毫秒的最少时间</code></strong>，这样在计时 <code>时间少于4毫秒时又带来了偏差</code></li><li>受 <strong><code>事件循环</code></strong> 的影响，计时器的回调函数只能在 <strong><code>主线程空闲时运行</code></strong>，因此又带来了偏差</li></ol><h3 id="何为异步" tabindex="-1"><a class="header-anchor" href="#何为异步"><span>何为异步</span></a></h3><p>JS是一门单线程的语言，这是因为它运行在浏览器的 <strong>渲染主线程</strong> 中，而 <strong>渲染主线程</strong> 只有一个。</p><p>而渲染主线程承担着诸多的工作，<strong>渲染页面</strong>、<strong>执行JS</strong> 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生 <strong>阻塞</strong>，从而导致消息队列中的很多其他任务无法得到执行。</p><p>这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免。</p><p>具体做法是当某些任务发生时，比如 <strong>计时器</strong>、<strong>网络</strong>、<strong>事件监听</strong>，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。</p><p>当其他线程完成时，将事先传递的<strong>回调函数包装成任务</strong>，加入到 <strong>消息队列</strong> 的 <strong>末尾排队</strong>，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p><h3 id="为什么要虚拟dom" tabindex="-1"><a class="header-anchor" href="#为什么要虚拟dom"><span>为什么要虚拟DOM</span></a></h3><ol><li>框架设计： 渲染页面运行render函数，组件化开发时，属性改变时只能全量渲染，直接操作DOM代价过高，使用虚拟DOM代替</li><li>跨平台：除了浏览器环境不存在dom，打包其他环境的时候可以用虚拟dom坐中间转换</li></ol><h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络"><span>网络</span></a></h2><h3 id="同源与跨域" tabindex="-1"><a class="header-anchor" href="#同源与跨域"><span>同源与跨域</span></a></h3><h4 id="同源策略限制了什么" tabindex="-1"><a class="header-anchor" href="#同源策略限制了什么"><span>同源策略限制了什么</span></a></h4><ol><li>DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作</li><li>数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据</li><li>网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点</li></ol><h4 id="跨域三要素" tabindex="-1"><a class="header-anchor" href="#跨域三要素"><span>跨域三要素</span></a></h4><p>浏览器限制：即浏览器对跨域行为进行检测和阻止 触发跨域的三要素之一：协议、域名、端口 发起的是xhr请求：即XMLHttpRequest</p><h4 id="如何解决跨域" tabindex="-1"><a class="header-anchor" href="#如何解决跨域"><span>如何解决跨域</span></a></h4><p>被调用方解决跨域设置 访问控制允许来源 response.addHeader(‘Access-Control-Allow-Origin’,’*’ ) 调用方使用Nginx 代理调用方请求，目的是为了和被调用方的域名端口保持一致 jsonp</p><h4 id="a-com-b-com-跨域发生在一步" tabindex="-1"><a class="header-anchor" href="#a-com-b-com-跨域发生在一步"><span>a.com -&gt; b.com 跨域发生在一步</span></a></h4><h3 id="get请求跨域吗" tabindex="-1"><a class="header-anchor" href="#get请求跨域吗"><span>get请求跨域吗</span></a></h3><h3 id="什么时候会发送预检请求" tabindex="-1"><a class="header-anchor" href="#什么时候会发送预检请求"><span>什么时候会发送预检请求</span></a></h3><h3 id="网络策略" tabindex="-1"><a class="header-anchor" href="#网络策略"><span>网络策略</span></a></h3><h4 id="cors-跨源资源共享" tabindex="-1"><a class="header-anchor" href="#cors-跨源资源共享"><span>CORS 跨源资源共享</span></a></h4><h4 id="csp-内容安全策略" tabindex="-1"><a class="header-anchor" href="#csp-内容安全策略"><span>CSP 内容安全策略</span></a></h4><p>同源策略是期望让我们的页面引用的资源都来自一个源，对于不是同源的文件，我们默认就是不安全的 CSP的核心思想就是让服务器决定浏览器可以加载那些资源，让服务器决定浏览器是否能够执行加载的JS代码。 Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</p><h2 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3"><span>Vue3</span></a></h2><h3 id="ref-和-reactive的用法" tabindex="-1"><a class="header-anchor" href="#ref-和-reactive的用法"><span>ref 和 reactive的用法</span></a></h3><h3 id="reactive的响应式" tabindex="-1"><a class="header-anchor" href="#reactive的响应式"><span>reactive的响应式</span></a></h3><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react"><span>React</span></a></h2><h3 id="类组件-和-函数组件-的区别" tabindex="-1"><a class="header-anchor" href="#类组件-和-函数组件-的区别"><span>类组件 和 函数组件 的区别</span></a></h3><h3 id="usestate-和-useref" tabindex="-1"><a class="header-anchor" href="#usestate-和-useref"><span>useState 和 useRef</span></a></h3><h3 id="uselayouteffect" tabindex="-1"><a class="header-anchor" href="#uselayouteffect"><span>useLayoutEffect</span></a></h3><h2 id="代码测试" tabindex="-1"><a class="header-anchor" href="#代码测试"><span>代码测试</span></a></h2><h2 id="灵活" tabindex="-1"><a class="header-anchor" href="#灵活"><span>灵活</span></a></h2><h3 id="长列表问题" tabindex="-1"><a class="header-anchor" href="#长列表问题"><span>长列表问题</span></a></h3><ol><li>帧动画加载</li><li>冻结数组</li><li>触底加载</li><li>文档碎片Fragment</li></ol>',60),l=[r];function s(i,c){return t(),o("div",null,l)}const p=e(n,[["render",s],["__file","index.html.vue"]]),g=JSON.parse('{"path":"/InterviewQuestion/","title":"面试题汇总","lang":"zh-CN","frontmatter":{"title":"面试题汇总","lang":"zh-CN","date":"2024-05-05T16:59:31.000Z","permalink":"/InterviewQuestion/","headerDepth":5,"gitInclude":["../../../src/zh/JavaScript/闭包以及内存泄漏原因.md","../../../src/zh/JavaScript/网络/AJAX - XHR与Fetch.md","../../../src/zh/JavaScript/浏览器/浏览器渲染原理.md","../../../src/zh/JavaScript/浏览器/浏览器进程模型.md","../../../src/zh/JavaScript/浏览器/浏览器进程模型.md","../../../src/zh/JavaScript/浏览器/浏览器进程模型.md"],"description":"闭包 描述： 函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包 特点： 可以重复利用变量，并且这个变量不会污染全局；这个变量一直保存在内存中，不会被垃圾回收机制回收 缺点： 闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露 使用： 防抖，节流，函数嵌套函数避免全局污染 高级描述： 函数 + 其定义时所处的词法环境 ...","head":[["meta",{"property":"og:url","content":"https://shaohui-jin.github.io/InterviewQuestion/"}],["meta",{"property":"og:title","content":"面试题汇总"}],["meta",{"property":"og:description","content":"闭包 描述： 函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包 特点： 可以重复利用变量，并且这个变量不会污染全局；这个变量一直保存在内存中，不会被垃圾回收机制回收 缺点： 闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露 使用： 防抖，节流，函数嵌套函数避免全局污染 高级描述： 函数 + 其定义时所处的词法环境 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-17T11:56:07.000Z"}],["meta",{"property":"article:author","content":"石怜安"}],["meta",{"property":"article:published_time","content":"2024-05-05T16:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-17T11:56:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试题汇总\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-05T16:59:31.000Z\\",\\"dateModified\\":\\"2024-06-17T11:56:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"石怜安\\",\\"url\\":\\"https://shaohui-jin.github.io\\"}]}"]]},"headers":[{"level":3,"title":"闭包","slug":"闭包","link":"#闭包","children":[]},{"level":3,"title":"ajax","slug":"ajax","link":"#ajax","children":[]},{"level":3,"title":"浏览器渲染原理","slug":"浏览器渲染原理","link":"#浏览器渲染原理","children":[]},{"level":3,"title":"事件循环","slug":"事件循环","link":"#事件循环","children":[]},{"level":3,"title":"JS 中的计时器能做到精确计时吗","slug":"js-中的计时器能做到精确计时吗","link":"#js-中的计时器能做到精确计时吗","children":[]},{"level":3,"title":"何为异步","slug":"何为异步","link":"#何为异步","children":[]},{"level":3,"title":"为什么要虚拟DOM","slug":"为什么要虚拟dom","link":"#为什么要虚拟dom","children":[]},{"level":2,"title":"网络","slug":"网络","link":"#网络","children":[{"level":3,"title":"同源与跨域","slug":"同源与跨域","link":"#同源与跨域","children":[{"level":4,"title":"同源策略限制了什么","slug":"同源策略限制了什么","link":"#同源策略限制了什么","children":[]},{"level":4,"title":"跨域三要素","slug":"跨域三要素","link":"#跨域三要素","children":[]},{"level":4,"title":"如何解决跨域","slug":"如何解决跨域","link":"#如何解决跨域","children":[]},{"level":4,"title":"a.com -> b.com 跨域发生在一步","slug":"a-com-b-com-跨域发生在一步","link":"#a-com-b-com-跨域发生在一步","children":[]}]},{"level":3,"title":"get请求跨域吗","slug":"get请求跨域吗","link":"#get请求跨域吗","children":[]},{"level":3,"title":"什么时候会发送预检请求","slug":"什么时候会发送预检请求","link":"#什么时候会发送预检请求","children":[]},{"level":3,"title":"网络策略","slug":"网络策略","link":"#网络策略","children":[{"level":4,"title":"CORS 跨源资源共享","slug":"cors-跨源资源共享","link":"#cors-跨源资源共享","children":[]},{"level":4,"title":"CSP 内容安全策略","slug":"csp-内容安全策略","link":"#csp-内容安全策略","children":[]}]}]},{"level":2,"title":"Vue3","slug":"vue3","link":"#vue3","children":[{"level":3,"title":"ref 和 reactive的用法","slug":"ref-和-reactive的用法","link":"#ref-和-reactive的用法","children":[]},{"level":3,"title":"reactive的响应式","slug":"reactive的响应式","link":"#reactive的响应式","children":[]}]},{"level":2,"title":"React","slug":"react","link":"#react","children":[{"level":3,"title":"类组件 和 函数组件 的区别","slug":"类组件-和-函数组件-的区别","link":"#类组件-和-函数组件-的区别","children":[]},{"level":3,"title":"useState 和 useRef","slug":"usestate-和-useref","link":"#usestate-和-useref","children":[]},{"level":3,"title":"useLayoutEffect","slug":"uselayouteffect","link":"#uselayouteffect","children":[]}]},{"level":2,"title":"代码测试","slug":"代码测试","link":"#代码测试","children":[]},{"level":2,"title":"灵活","slug":"灵活","link":"#灵活","children":[{"level":3,"title":"长列表问题","slug":"长列表问题","link":"#长列表问题","children":[]}]}],"git":{"createdTime":1712308326000,"updatedTime":1718625367000,"contributors":[{"name":"shaohui_jin","email":"1051131737@qq.com","commits":10}]},"readingTime":{"minutes":2.19,"words":656},"filePathRelative":"zh/面试题 - 随时看看/面试题汇总.md","localizedDate":"2024年5月5日","excerpt":"<h3>闭包</h3>\\n<p><code>描述</code>： 函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包</p>\\n<p><code>特点</code>： 可以重复利用变量，并且这个变量不会污染全局；这个变量一直保存在内存中，不会被垃圾回收机制回收</p>\\n<p><code>缺点</code>： 闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露</p>\\n<p><code>使用</code>： 防抖，节流，函数嵌套函数避免全局污染</p>\\n<blockquote>\\n<p><strong>高级描述：</strong></p>\\n<ol>\\n<li><code>函数</code> + <code>其定义时所处的词法环境</code></li>\\n<li><code>函数本身</code> + <code>内部属性[Environment]</code></li>\\n</ol>\\n<p><strong>内存泄漏条件：</strong></p>\\n<ol>\\n<li><strong>持有了不再需要的函数引用，会导致函数关联的 <code>词法环境</code> 无法销毁，从而导致内存泄露</strong></li>\\n<li><strong>当多个函数 <code>共享词法环境</code> 时，会导致词法环境膨胀，从而导致出现 <code>无法触达</code> 也 <code>无法回收</code> 的内存空间，导致内存泄漏</strong></li>\\n</ol>\\n</blockquote>","autoDesc":true}');export{p as comp,g as data};
