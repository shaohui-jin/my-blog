import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as l,b as t}from"./app-CLMeatBe.js";const i={},n=t('<h2 id="后续暂未整理" tabindex="-1"><a class="header-anchor" href="#后续暂未整理"><span>后续暂未整理</span></a></h2><h3 id="vue的computed跟普通的函数有什么区别吗-computed怎么实现缓存的-有看过源码吗" tabindex="-1"><a class="header-anchor" href="#vue的computed跟普通的函数有什么区别吗-computed怎么实现缓存的-有看过源码吗"><span>vue的computed跟普通的函数有什么区别吗，computed怎么实现缓存的，有看过源码吗</span></a></h3><h3 id="vue-router实现原理的-history-相关的api" tabindex="-1"><a class="header-anchor" href="#vue-router实现原理的-history-相关的api"><span>vue-router实现原理的 history 相关的api</span></a></h3><h2 id="webpack模块" tabindex="-1"><a class="header-anchor" href="#webpack模块"><span>webpack模块</span></a></h2><h3 id="webpack中-bundle-chunk-module-有什么区别" tabindex="-1"><a class="header-anchor" href="#webpack中-bundle-chunk-module-有什么区别"><span>webpack中 bundle chunk module 有什么区别</span></a></h3><h3 id="webpack中-plugin-loader-有什么区别" tabindex="-1"><a class="header-anchor" href="#webpack中-plugin-loader-有什么区别"><span>webpack中 plugin loader 有什么区别</span></a></h3><h3 id="同源与跨域" tabindex="-1"><a class="header-anchor" href="#同源与跨域"><span>同源与跨域</span></a></h3><h4 id="同源策略限制了什么" tabindex="-1"><a class="header-anchor" href="#同源策略限制了什么"><span>同源策略限制了什么</span></a></h4><ol><li>DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作</li><li>数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据</li><li>网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点</li></ol><h4 id="跨域三要素" tabindex="-1"><a class="header-anchor" href="#跨域三要素"><span>跨域三要素</span></a></h4><p>浏览器限制：即浏览器对跨域行为进行检测和阻止 触发跨域的三要素之一：协议、域名、端口 发起的是xhr请求：即XMLHttpRequest</p><h4 id="如何解决跨域" tabindex="-1"><a class="header-anchor" href="#如何解决跨域"><span>如何解决跨域</span></a></h4><p>被调用方解决跨域设置 访问控制允许来源 response.addHeader(‘Access-Control-Allow-Origin’,’*’ ) 调用方使用Nginx 代理调用方请求，目的是为了和被调用方的域名端口保持一致 jsonp</p><h4 id="a-com-b-com-跨域发生在一步" tabindex="-1"><a class="header-anchor" href="#a-com-b-com-跨域发生在一步"><span>a.com -&gt; b.com 跨域发生在一步</span></a></h4><h3 id="get请求跨域吗" tabindex="-1"><a class="header-anchor" href="#get请求跨域吗"><span>get请求跨域吗</span></a></h3><h3 id="什么时候会发送预检请求" tabindex="-1"><a class="header-anchor" href="#什么时候会发送预检请求"><span>什么时候会发送预检请求</span></a></h3><h3 id="网络策略" tabindex="-1"><a class="header-anchor" href="#网络策略"><span>网络策略</span></a></h3><h4 id="cors-跨源资源共享" tabindex="-1"><a class="header-anchor" href="#cors-跨源资源共享"><span>CORS 跨源资源共享</span></a></h4><h4 id="csp-内容安全策略" tabindex="-1"><a class="header-anchor" href="#csp-内容安全策略"><span>CSP 内容安全策略</span></a></h4><p>同源策略是期望让我们的页面引用的资源都来自一个源，对于不是同源的文件，我们默认就是不安全的 CSP的核心思想就是让服务器决定浏览器可以加载那些资源，让服务器决定浏览器是否能够执行加载的JS代码。 Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</p><h2 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3"><span>Vue3</span></a></h2><h3 id="ref-和-reactive的用法" tabindex="-1"><a class="header-anchor" href="#ref-和-reactive的用法"><span>ref 和 reactive的用法</span></a></h3><h3 id="reactive的响应式" tabindex="-1"><a class="header-anchor" href="#reactive的响应式"><span>reactive的响应式</span></a></h3><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react"><span>React</span></a></h2><h3 id="类组件-和-函数组件-的区别" tabindex="-1"><a class="header-anchor" href="#类组件-和-函数组件-的区别"><span>类组件 和 函数组件 的区别</span></a></h3><h3 id="usestate-和-useref" tabindex="-1"><a class="header-anchor" href="#usestate-和-useref"><span>useState 和 useRef</span></a></h3><h3 id="uselayouteffect" tabindex="-1"><a class="header-anchor" href="#uselayouteffect"><span>useLayoutEffect</span></a></h3><h2 id="代码测试" tabindex="-1"><a class="header-anchor" href="#代码测试"><span>代码测试</span></a></h2><h2 id="灵活" tabindex="-1"><a class="header-anchor" href="#灵活"><span>灵活</span></a></h2><h3 id="长列表问题" tabindex="-1"><a class="header-anchor" href="#长列表问题"><span>长列表问题</span></a></h3><ol><li>帧动画加载</li><li>冻结数组</li><li>触底加载</li><li>文档碎片Fragment</li></ol>',31),r=[n];function c(h,s){return a(),l("div",null,r)}const p=e(i,[["render",c],["__file","未整理.html.vue"]]),u=JSON.parse('{"path":"/zh/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%9C%AA%E6%95%B4%E7%90%86.html","title":"","lang":"zh-CN","frontmatter":{"headerDepth":3,"description":"后续暂未整理 vue的computed跟普通的函数有什么区别吗，computed怎么实现缓存的，有看过源码吗 vue-router实现原理的 history 相关的api webpack模块 webpack中 bundle chunk module 有什么区别 webpack中 plugin loader 有什么区别 同源与跨域 同源策略限制了什么 D...","head":[["meta",{"property":"og:url","content":"https://shaohui-jin.github.io/zh/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%9C%AA%E6%95%B4%E7%90%86.html"}],["meta",{"property":"og:description","content":"后续暂未整理 vue的computed跟普通的函数有什么区别吗，computed怎么实现缓存的，有看过源码吗 vue-router实现原理的 history 相关的api webpack模块 webpack中 bundle chunk module 有什么区别 webpack中 plugin loader 有什么区别 同源与跨域 同源策略限制了什么 D..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-22T12:43:16.000Z"}],["meta",{"property":"article:author","content":"石怜安"}],["meta",{"property":"article:modified_time","content":"2025-05-22T12:43:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-22T12:43:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"石怜安\\",\\"url\\":\\"https://shaohui-jin.github.io\\"}]}"]]},"headers":[{"level":2,"title":"后续暂未整理","slug":"后续暂未整理","link":"#后续暂未整理","children":[{"level":3,"title":"vue的computed跟普通的函数有什么区别吗，computed怎么实现缓存的，有看过源码吗","slug":"vue的computed跟普通的函数有什么区别吗-computed怎么实现缓存的-有看过源码吗","link":"#vue的computed跟普通的函数有什么区别吗-computed怎么实现缓存的-有看过源码吗","children":[]},{"level":3,"title":"vue-router实现原理的 history 相关的api","slug":"vue-router实现原理的-history-相关的api","link":"#vue-router实现原理的-history-相关的api","children":[]}]},{"level":2,"title":"webpack模块","slug":"webpack模块","link":"#webpack模块","children":[{"level":3,"title":"webpack中 bundle chunk module 有什么区别","slug":"webpack中-bundle-chunk-module-有什么区别","link":"#webpack中-bundle-chunk-module-有什么区别","children":[]},{"level":3,"title":"webpack中 plugin loader 有什么区别","slug":"webpack中-plugin-loader-有什么区别","link":"#webpack中-plugin-loader-有什么区别","children":[]},{"level":3,"title":"同源与跨域","slug":"同源与跨域","link":"#同源与跨域","children":[{"level":4,"title":"同源策略限制了什么","slug":"同源策略限制了什么","link":"#同源策略限制了什么","children":[]},{"level":4,"title":"跨域三要素","slug":"跨域三要素","link":"#跨域三要素","children":[]},{"level":4,"title":"如何解决跨域","slug":"如何解决跨域","link":"#如何解决跨域","children":[]},{"level":4,"title":"a.com -> b.com 跨域发生在一步","slug":"a-com-b-com-跨域发生在一步","link":"#a-com-b-com-跨域发生在一步","children":[]}]},{"level":3,"title":"get请求跨域吗","slug":"get请求跨域吗","link":"#get请求跨域吗","children":[]},{"level":3,"title":"什么时候会发送预检请求","slug":"什么时候会发送预检请求","link":"#什么时候会发送预检请求","children":[]},{"level":3,"title":"网络策略","slug":"网络策略","link":"#网络策略","children":[{"level":4,"title":"CORS 跨源资源共享","slug":"cors-跨源资源共享","link":"#cors-跨源资源共享","children":[]},{"level":4,"title":"CSP 内容安全策略","slug":"csp-内容安全策略","link":"#csp-内容安全策略","children":[]}]}]},{"level":2,"title":"Vue3","slug":"vue3","link":"#vue3","children":[{"level":3,"title":"ref 和 reactive的用法","slug":"ref-和-reactive的用法","link":"#ref-和-reactive的用法","children":[]},{"level":3,"title":"reactive的响应式","slug":"reactive的响应式","link":"#reactive的响应式","children":[]}]},{"level":2,"title":"React","slug":"react","link":"#react","children":[{"level":3,"title":"类组件 和 函数组件 的区别","slug":"类组件-和-函数组件-的区别","link":"#类组件-和-函数组件-的区别","children":[]},{"level":3,"title":"useState 和 useRef","slug":"usestate-和-useref","link":"#usestate-和-useref","children":[]},{"level":3,"title":"useLayoutEffect","slug":"uselayouteffect","link":"#uselayouteffect","children":[]}]},{"level":2,"title":"代码测试","slug":"代码测试","link":"#代码测试","children":[]},{"level":2,"title":"灵活","slug":"灵活","link":"#灵活","children":[{"level":3,"title":"长列表问题","slug":"长列表问题","link":"#长列表问题","children":[]}]}],"git":{"createdTime":1747917796000,"updatedTime":1747917796000,"contributors":[{"name":"shaohui_jin","email":"1051131737@qq.com","commits":1}]},"readingTime":{"minutes":1.67,"words":501},"filePathRelative":"zh/面试题/未整理.md","localizedDate":"2025年5月22日","excerpt":"<h2>后续暂未整理</h2>\\n<h3>vue的computed跟普通的函数有什么区别吗，computed怎么实现缓存的，有看过源码吗</h3>\\n<h3>vue-router实现原理的 history 相关的api</h3>\\n<h2>webpack模块</h2>\\n<h3>webpack中 bundle chunk module 有什么区别</h3>\\n<h3>webpack中 plugin loader 有什么区别</h3>\\n<h3>同源与跨域</h3>\\n<h4>同源策略限制了什么</h4>\\n<ol>\\n<li>DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作</li>\\n<li>数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据</li>\\n<li>网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点</li>\\n</ol>","autoDesc":true}');export{p as comp,u as data};
