import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as t,b as l}from"./app-QEI7XTbO.js";const i={},n=l('<h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络"><span>网络</span></a></h2><h3 id="同源与跨域" tabindex="-1"><a class="header-anchor" href="#同源与跨域"><span>同源与跨域</span></a></h3><h4 id="同源策略限制了什么" tabindex="-1"><a class="header-anchor" href="#同源策略限制了什么"><span>同源策略限制了什么</span></a></h4><ol><li>DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作</li><li>数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据</li><li>网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点</li></ol><h4 id="跨域三要素" tabindex="-1"><a class="header-anchor" href="#跨域三要素"><span>跨域三要素</span></a></h4><p>浏览器限制：即浏览器对跨域行为进行检测和阻止 触发跨域的三要素之一：协议、域名、端口 发起的是xhr请求：即XMLHttpRequest</p><h4 id="如何解决跨域" tabindex="-1"><a class="header-anchor" href="#如何解决跨域"><span>如何解决跨域</span></a></h4><p>被调用方解决跨域设置 访问控制允许来源 response.addHeader(‘Access-Control-Allow-Origin’,’*’ ) 调用方使用Nginx 代理调用方请求，目的是为了和被调用方的域名端口保持一致 jsonp</p><h4 id="a-com-b-com-跨域发生在一步" tabindex="-1"><a class="header-anchor" href="#a-com-b-com-跨域发生在一步"><span>a.com -&gt; b.com 跨域发生在一步</span></a></h4><h3 id="get请求跨域吗" tabindex="-1"><a class="header-anchor" href="#get请求跨域吗"><span>get请求跨域吗</span></a></h3><h3 id="什么时候会发送预检请求" tabindex="-1"><a class="header-anchor" href="#什么时候会发送预检请求"><span>什么时候会发送预检请求</span></a></h3><h3 id="网络策略" tabindex="-1"><a class="header-anchor" href="#网络策略"><span>网络策略</span></a></h3><h4 id="cors-跨源资源共享" tabindex="-1"><a class="header-anchor" href="#cors-跨源资源共享"><span>CORS 跨源资源共享</span></a></h4><h4 id="csp-内容安全策略" tabindex="-1"><a class="header-anchor" href="#csp-内容安全策略"><span>CSP 内容安全策略</span></a></h4><p>同源策略是期望让我们的页面引用的资源都来自一个源，对于不是同源的文件，我们默认就是不安全的 CSP的核心思想就是让服务器决定浏览器可以加载那些资源，让服务器决定浏览器是否能够执行加载的JS代码。 Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</p><h2 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3"><span>Vue3</span></a></h2><h3 id="ref-和-reactive的用法" tabindex="-1"><a class="header-anchor" href="#ref-和-reactive的用法"><span>ref 和 reactive的用法</span></a></h3><h3 id="reactive的响应式" tabindex="-1"><a class="header-anchor" href="#reactive的响应式"><span>reactive的响应式</span></a></h3><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react"><span>React</span></a></h2><h3 id="类组件-和-函数组件-的区别" tabindex="-1"><a class="header-anchor" href="#类组件-和-函数组件-的区别"><span>类组件 和 函数组件 的区别</span></a></h3><h3 id="usestate-和-useref" tabindex="-1"><a class="header-anchor" href="#usestate-和-useref"><span>useState 和 useRef</span></a></h3><h3 id="uselayouteffect" tabindex="-1"><a class="header-anchor" href="#uselayouteffect"><span>useLayoutEffect</span></a></h3><h2 id="代码测试" tabindex="-1"><a class="header-anchor" href="#代码测试"><span>代码测试</span></a></h2><h2 id="灵活" tabindex="-1"><a class="header-anchor" href="#灵活"><span>灵活</span></a></h2><h3 id="长列表问题" tabindex="-1"><a class="header-anchor" href="#长列表问题"><span>长列表问题</span></a></h3><ol><li>帧动画加载</li><li>冻结数组</li><li>触底加载</li><li>文档碎片Fragment</li></ol>',26),s=[n];function r(c,h){return a(),t("div",null,s)}const p=e(i,[["render",r],["__file","index.html.vue"]]),u=JSON.parse('{"path":"/InterviewQuestion/","title":"面试题汇总","lang":"zh-CN","frontmatter":{"title":"面试题汇总","lang":"zh-CN","date":"2024-05-05T16:59:31.000Z","permalink":"/InterviewQuestion/","headerDepth":5,"description":"网络 同源与跨域 同源策略限制了什么 DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作 数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据 网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点 跨域三要素 浏览器限制：...","head":[["meta",{"property":"og:url","content":"https://shaohui-jin.github.io/InterviewQuestion/"}],["meta",{"property":"og:title","content":"面试题汇总"}],["meta",{"property":"og:description","content":"网络 同源与跨域 同源策略限制了什么 DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作 数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据 网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点 跨域三要素 浏览器限制：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-29T07:52:09.000Z"}],["meta",{"property":"article:author","content":"石怜安"}],["meta",{"property":"article:published_time","content":"2024-05-05T16:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-29T07:52:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试题汇总\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-05T16:59:31.000Z\\",\\"dateModified\\":\\"2024-05-29T07:52:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"石怜安\\",\\"url\\":\\"https://shaohui-jin.github.io\\"}]}"]]},"headers":[{"level":2,"title":"网络","slug":"网络","link":"#网络","children":[{"level":3,"title":"同源与跨域","slug":"同源与跨域","link":"#同源与跨域","children":[{"level":4,"title":"同源策略限制了什么","slug":"同源策略限制了什么","link":"#同源策略限制了什么","children":[]},{"level":4,"title":"跨域三要素","slug":"跨域三要素","link":"#跨域三要素","children":[]},{"level":4,"title":"如何解决跨域","slug":"如何解决跨域","link":"#如何解决跨域","children":[]},{"level":4,"title":"a.com -> b.com 跨域发生在一步","slug":"a-com-b-com-跨域发生在一步","link":"#a-com-b-com-跨域发生在一步","children":[]}]},{"level":3,"title":"get请求跨域吗","slug":"get请求跨域吗","link":"#get请求跨域吗","children":[]},{"level":3,"title":"什么时候会发送预检请求","slug":"什么时候会发送预检请求","link":"#什么时候会发送预检请求","children":[]},{"level":3,"title":"网络策略","slug":"网络策略","link":"#网络策略","children":[{"level":4,"title":"CORS 跨源资源共享","slug":"cors-跨源资源共享","link":"#cors-跨源资源共享","children":[]},{"level":4,"title":"CSP 内容安全策略","slug":"csp-内容安全策略","link":"#csp-内容安全策略","children":[]}]}]},{"level":2,"title":"Vue3","slug":"vue3","link":"#vue3","children":[{"level":3,"title":"ref 和 reactive的用法","slug":"ref-和-reactive的用法","link":"#ref-和-reactive的用法","children":[]},{"level":3,"title":"reactive的响应式","slug":"reactive的响应式","link":"#reactive的响应式","children":[]}]},{"level":2,"title":"React","slug":"react","link":"#react","children":[{"level":3,"title":"类组件 和 函数组件 的区别","slug":"类组件-和-函数组件-的区别","link":"#类组件-和-函数组件-的区别","children":[]},{"level":3,"title":"useState 和 useRef","slug":"usestate-和-useref","link":"#usestate-和-useref","children":[]},{"level":3,"title":"useLayoutEffect","slug":"uselayouteffect","link":"#uselayouteffect","children":[]}]},{"level":2,"title":"代码测试","slug":"代码测试","link":"#代码测试","children":[]},{"level":2,"title":"灵活","slug":"灵活","link":"#灵活","children":[{"level":3,"title":"长列表问题","slug":"长列表问题","link":"#长列表问题","children":[]}]}],"git":{"createdTime":1714900279000,"updatedTime":1716969129000,"contributors":[{"name":"shaohui_jin","email":"1051131737@qq.com","commits":2}]},"readingTime":{"minutes":1.51,"words":452},"filePathRelative":"zh/面试题 - 随时看看/面试题汇总.md","localizedDate":"2024年5月5日","excerpt":"<h2>网络</h2>\\n<h3>同源与跨域</h3>\\n<h4>同源策略限制了什么</h4>\\n<ol>\\n<li>DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作</li>\\n<li>数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据</li>\\n<li>网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点</li>\\n</ol>\\n<h4>跨域三要素</h4>\\n<p>浏览器限制：即浏览器对跨域行为进行检测和阻止\\n触发跨域的三要素之一：协议、域名、端口\\n发起的是xhr请求：即XMLHttpRequest</p>","autoDesc":true}');export{p as comp,u as data};
