<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.8" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.30" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://shaohui-jin.github.io/my-blog/Algorithm/DynamicProgram/"><meta property="og:title" content="动态规划算法"><meta property="og:description" content="算法认识 动态规划（Dynamic Programming）简称 DP，对于子问题重叠的情况特别有效，因为它将子问题的解保存在表格中，当需要某个子问题的解时，直接取值即可，从而避免重复计算。 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。 动态规划算法与分治法类似，..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-04-24T09:52:09.000Z"><meta property="article:author" content="石怜安"><meta property="article:tag" content="很菜的算法"><meta property="article:published_time" content="2022-06-06T16:38:19.000Z"><meta property="article:modified_time" content="2025-04-24T09:52:09.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"动态规划算法","image":[""],"datePublished":"2022-06-06T16:38:19.000Z","dateModified":"2025-04-24T09:52:09.000Z","author":[{"@type":"Person","name":"石怜安","url":"https://shaohui-jin.github.io"}]}</script><link rel="javascript" href="https://cdn.bootcdn.net/ajax/libs/view-design/4.7.0/iview.js"><meta name="baidu-site-verification" content="nGf5yi0Gec"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#5c92d1"><title>动态规划算法</title><meta name="description" content="算法认识 动态规划（Dynamic Programming）简称 DP，对于子问题重叠的情况特别有效，因为它将子问题的解保存在表格中，当需要某个子问题的解时，直接取值即可，从而避免重复计算。 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。 动态规划算法与分治法类似，...">
    <link rel="preload" href="/my-blog/assets/style-Dn1WXpcu.css" as="style"><link rel="stylesheet" href="/my-blog/assets/style-Dn1WXpcu.css">
    <link rel="modulepreload" href="/my-blog/assets/app-EVybbKqM.js"><link rel="modulepreload" href="/my-blog/assets/index.html-B7g-GhoG.js"><link rel="modulepreload" href="/my-blog/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/my-blog/assets/index.html-foecZTo5.js" as="script"><link rel="prefetch" href="/my-blog/assets/intro.html-3FxvgD0u.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BDAulFfm.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-ObgwV3aQ.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-51H-96hJ.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DMClo9h1.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DoJmTXEc.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BPCW5dYr.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-JxM_UE_D.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-C8p-7X2H.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BKKAS29z.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Bxzia1Lq.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BNPDEvJ1.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BvpyXTgk.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-B1seOc4k.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-O-L_-lca.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-D-R0I1Qj.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-MYfoM8JQ.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DHi9rPtX.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DTct8wmc.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CSfKoHwE.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-B12I8wqb.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-udtDCiEU.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-R8JUpDE1.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Dx8tmjR6.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DVxZ60Wx.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BoEf6r_F.js" as="script"><link rel="prefetch" href="/my-blog/assets/CSS.html-CZdOPI4X.js" as="script"><link rel="prefetch" href="/my-blog/assets/ES.html-DcYSa_Hb.js" as="script"><link rel="prefetch" href="/my-blog/assets/JS.html-DbUnvgIq.js" as="script"><link rel="prefetch" href="/my-blog/assets/Node.html-BvMiz4ZV.js" as="script"><link rel="prefetch" href="/my-blog/assets/Vue.html-CiKrjB0L.js" as="script"><link rel="prefetch" href="/my-blog/assets/未整理.html-DzvLCVhp.js" as="script"><link rel="prefetch" href="/my-blog/assets/网络.html-DpMDtpTQ.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DCnXUW3b.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BE6vTAYy.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CilU-FQD.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CkOcgTOu.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CX_EQYij.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-zlHJNpv-.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CbrkUkZu.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DEvIoHXA.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CrlR_Oaj.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BHASO5Qp.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DaOIJ1xr.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CUvhw404.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-C8xFFpD8.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-kXZ1pSWt.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BuRqWXJ5.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BYgWbltA.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CnRTPEB1.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-hIqhNBtK.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CEnJ_TVu.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Ce6poDjy.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DlWAEGSc.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BlB3ShH1.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-B3Ms2mLl.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Ex-Xhdii.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Cxve-luR.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-D4WcFzOS.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BiZK5M0A.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-QnoRW3KL.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Dp6NKTFj.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DgbNZBMD.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-C9RFLwVl.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CynJIk2C.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DQL3TJqp.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BqHwE3-i.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CgUTCtqZ.js" as="script"><link rel="prefetch" href="/my-blog/assets/404.html-DJE0oV_H.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-C_FpaTX_.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BnXIOLJY.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-g740aKO6.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-D_h7OgX5.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Dawgkuwk.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CD49iRhI.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BpS8cxze.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-C57a9DtY.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DauQmaJe.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BMX71Mmj.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CoNL2eRN.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-C9tgdyZX.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-C7s6GMNm.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DiqihmV2.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-tOUkmqDs.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-B-1w_Cef.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DILndNYS.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-QrNiDlhK.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CsfVbov0.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BlDOex9w.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CVKwR6Ec.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DDLS5M05.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DcZPCt62.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CxKaxGId.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-5n3CAMry.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CBO-zLcU.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Bug3V9Mp.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-K4-6QQjP.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CjQDE_8e.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DwHNaSCK.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Bpe_oNFx.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BXUQNsJO.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CWO-v1y1.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-yY_Yv0Of.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Du4pbOQm.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-C59605kt.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CrpWmH4H.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CedRkvXk.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-ulH4kjk9.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-pfCyeKoi.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CESv7j9R.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-MvfrG_Uk.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-cpoYfFrY.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BAjQxEew.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-O74DAPb-.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-B3l1W0C2.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Cvb9-Z71.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BRd6_8ae.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Csvn3KcK.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Twv-8t3a.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-M0hIIDkE.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-uL-n1cmf.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-wpuXBdZU.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-uuhDL0xp.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-B3hRI1UZ.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-B2eDqzTP.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-CcgnfHGW.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BHTdDD00.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Dj9qK0aC.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-HuXpKB2B.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BsAT_C03.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BRvmAh4J.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BprXTAIT.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-Dzdd8ZDF.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BUZA4a26.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-DPJ_9Be-.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-BAH4YFBk.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-mNFo3rbi.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-pn12OS1S.js" as="script"><link rel="prefetch" href="/my-blog/assets/index.html-B_KD0Psn.js" as="script"><link rel="prefetch" href="/my-blog/assets/index-pqw0VMRF.js" as="script"><link rel="prefetch" href="/my-blog/assets/index-DRWmbcXV.js" as="script"><link rel="prefetch" href="/my-blog/assets/index-B6nmGEkk.js" as="script"><link rel="prefetch" href="/my-blog/assets/mermaid.core-ChrFzaVF.js" as="script"><link rel="prefetch" href="/my-blog/assets/vue-repl-DIR4bCnP.js" as="script"><link rel="prefetch" href="/my-blog/assets/codemirror-editor-BotFNGA9.js" as="script"><link rel="prefetch" href="/my-blog/assets/photoswipe.esm-SzV8tJDW.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/my-blog/"><img class="vp-nav-logo" src="https://shaohui-jin.github.io/picx-images-hosting/blog/Logo/User.73tpi84jwb.gif" alt><!----><!----></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/my-blog/" aria-label="首页"><!---->首页<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/my-blog/InterviewQuestion/" aria-label="每日复习"><span class="font-icon icon iconfont icon-iconfont icon-hot" style=""></span>每日复习<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/my-blog/Promotion/BFC/" aria-label="精选文章"><span class="font-icon icon iconfont icon-iconfont icon-hot" style=""></span>精选文章<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/my-blog/Tips/UseWorker/" aria-label="代码仓"><span class="font-icon icon iconfont icon-iconfont icon-hot" style=""></span>代码仓<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/my-blog/Java/Stream/" aria-label="Java"><!---->Java<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/my-blog/DesignPattern/Info/" aria-label="设计模式"><!---->设计模式<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link active" href="/my-blog/Algorithm/Dichotomy/" aria-label="常用算法"><!---->常用算法<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/my-blog/Recommend/CSS/" aria-label="推荐"><!---->推荐<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/my-blog/Algorithm/Dichotomy/" aria-label="二分查找理论"><!---->二分查找理论<!----></a></li><li><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/my-blog/Algorithm/DynamicProgram/" aria-label="动态规划算法"><!---->动态规划算法<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/my-blog/Algorithm/PriorityTraversal/" aria-label="优先遍历算法"><!---->优先遍历算法<!----></a></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->动态规划算法</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://shaohui-jin.github.io" target="_blank" rel="noopener noreferrer">石怜安</a></span><span property="author" content="石怜安"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2022-06-06T16:38:19.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 19 分钟</span><meta property="timeRequired" content="PT19M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category6 clickable" role="navigation">算法</span><!--]--><meta property="articleSection" content="算法"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag7 clickable" role="navigation">很菜的算法</span><!--]--><meta property="keywords" content="很菜的算法"></span></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/my-blog/#算法认识">算法认识</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/my-blog/#算法性质">算法性质</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#子问题重叠">子问题重叠</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#状态转移方程">状态转移方程</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#最优子结构">最优子结构</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#无后效性">无后效性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#自底向上">自底向上</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/my-blog/#步骤实战">步骤实战</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#斐波那契式子">斐波那契式子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#硬币凑钱">硬币凑钱</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/my-blog/#例题实战">例题实战</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#爬楼梯">爬楼梯</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#最小路径和">最小路径和</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/my-blog/#不同路径">不同路径</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/my-blog/#适用场景">适用场景</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/my-blog/#算法局限">算法局限</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h2 id="算法认识" tabindex="-1"><a class="header-anchor" href="#算法认识"><span>算法认识</span></a></h2><p>动态规划（Dynamic Programming）简称 DP，对于子问题重叠的情况特别有效，因为它将子问题的解保存在表格中，当需要某个子问题的解时，直接取值即可，从而避免重复计算。</p><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p><p>所以动态规划实际上是将问题分化成很多的子问题，然后将当前子问题计算过的最优结果存储起来，当另一个子问题也打算求该结果时，直接返回即可，因为已经是最优解。</p><p>动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「最优子结构」 ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑。</p><h2 id="算法性质" tabindex="-1"><a class="header-anchor" href="#算法性质"><span>算法性质</span></a></h2><p>动态规划有很多的「高大上」的术语和性质，这些性质也是算法需要考虑的步骤。</p><h3 id="子问题重叠" tabindex="-1"><a class="header-anchor" href="#子问题重叠"><span>子问题重叠</span></a></h3><p>子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p><p>也就是在求解的过程中，许多子问题的解被反复地使用。为了避免重复计算，动态规划算法采用了填表来保存子问题解。</p><h3 id="状态转移方程" tabindex="-1"><a class="header-anchor" href="#状态转移方程"><span>状态转移方程</span></a></h3><p><strong>动态规划最难的就是求解出状态转移方程</strong>，就类似于递推的公式，如：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// n 是 1,2,...,n</span>
dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment">// // i 是 1,2,...,i</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>f(n)</code> 由 <code>f(n - 1)</code> 和 <code>f(n - 2)</code> 不断转移，直至 n 才得到结果，这就是状态转移方程。</p><h3 id="最优子结构" tabindex="-1"><a class="header-anchor" href="#最优子结构"><span>最优子结构</span></a></h3><p>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。</p><p>原问题的解是由多个子问题的最优解构成，比如说，原问题是考出最高的总成绩，那么子问题就是要把语文考到最高，数学考到最高等，为了每门课考到最高，要把每门课相应的选择题分数拿到最高，填空题分数拿到最高等等，当然，最终就是每门课都是满分，这就是最高的总成绩。所以得到了最后正确的结果：最高的总成绩就是总分。</p><h3 id="无后效性" tabindex="-1"><a class="header-anchor" href="#无后效性"><span>无后效性</span></a></h3><p>即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>如 A -&gt; B -&gt; C，那么 B 和 C 的结果不会影响 A，同理 C 不会影响 B，但是 A 能影响 B 和 C，毕竟 B 和 C 是通过 A 的结果来算出。</p><h3 id="自底向上" tabindex="-1"><a class="header-anchor" href="#自底向上"><span>自底向上</span></a></h3><p>动态规划的特点就是从最底部（0 或者 1）蔓延到上面（n），假设存在长度 n，我们知道递归是从 n 到 n - 1 往下遍历，直至到 1，这叫 <strong>自顶向下</strong>。而动态规划是 <strong>自底向上</strong>，也就是从 1 到 2 往上遍历，直至到 n。</p><p>因为动态规划是自底向上，所以我们在求解的时候需要由一些原始条件，如：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样才有具体的值来自底向上：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="步骤实战" tabindex="-1"><a class="header-anchor" href="#步骤实战"><span>步骤实战</span></a></h2><p>动态规划遵循一套固定的流程：<strong>递归的暴力解法</strong> -&gt; <strong>带备忘录的递归解法</strong> -&gt; <strong>非递归的动态规划解法</strong>。这个过程是层层递进的解决问题的过程，如果没有前面的铺垫，直接看最终的非递归的动态规划解法，会难理解。</p><h3 id="斐波那契式子" tabindex="-1"><a class="header-anchor" href="#斐波那契式子"><span>斐波那契式子</span></a></h3><p>斐波那契式子为：<code>F(0) = 0，F(1) = 1, F(n) = F(n - 1) + F(n - 2)</code>。</p><h4 id="暴力的递归算法" tabindex="-1"><a class="header-anchor" href="#暴力的递归算法"><span>暴力的递归算法</span></a></h4><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自顶向下</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要想计算原问题 f(20)，就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，依次类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果。</p><p>子问题个数为 O(2^n)，所以这个算法的时间复杂度为 O(2^n)，效率很低。</p><p>这就是我们需要解决动态规划问题的第一个性质：<strong>重叠子问题</strong></p><h4 id="带备忘录的递归解法" tabindex="-1"><a class="header-anchor" href="#带备忘录的递归解法"><span>带备忘录的递归解法</span></a></h4><p>即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；后面每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>「备忘录」可以是数组，也可以是哈希表，key 为子问题的唯一标识，value 就是解决后的结果。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 备忘录全初始化为 0</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  memo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  memo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化最简情况</span>
  <span class="token function">fibMemo</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 1 1 2 3 5 8 13，因为 i 从 0 开始，所以 n - 1 就是结果</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fibMemo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 未被计算过</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fibMemo</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibMemo</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p>子问题个数为 O(n)。所以，本算法的时间复杂度是 O(n)。比起暴力算法，效率大幅度提升很多。</p><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h4 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span>动态规划</span></a></h4><p>有「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，叫做 dp，在这张表上完成「自底向上」的推算。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 状态转移方程</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 1 1 2 3 5 8 13，因为 i 从 0 开始，所以 n - 1 就是结果</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>dp[i] = dp[i - 1] + dp[i - 2];</code> 就是 <strong>状态转移方程</strong>，它是解决问题的核心。我们也很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>动态规划问题最困难的就是写出状态转移方程</strong>。</p><blockquote><p>动态规划优化</p></blockquote><p>根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 dp 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> curr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> prev <span class="token operator">+</span> curr<span class="token punctuation">;</span>
    prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
    curr <span class="token operator">=</span> sum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> curr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="硬币凑钱" tabindex="-1"><a class="header-anchor" href="#硬币凑钱"><span>硬币凑钱</span></a></h3><p>给 k 种面值的硬币，面值分别为 c1，c2，...，ck，再给一个总金额 n，问最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p><p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 <code>11 = 5 + 5 + 1</code>。</p><h4 id="暴力的递归算法-1" tabindex="-1"><a class="header-anchor" href="#暴力的递归算法-1"><span>暴力的递归算法</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 金额不可达</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> subProb <span class="token operator">=</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 子问题无解时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subProb <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ans <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> subProb <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ans <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总时间复杂度为 O(k*n^k)。</p><h4 id="带备忘录的递归算法" tabindex="-1"><a class="header-anchor" href="#带备忘录的递归算法"><span>带备忘录的递归算法</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 备忘录初始化为 -2</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 备忘录不为 -2 代表已经存有最优解</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 金额不可达</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> subProb <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 子问题无解时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subProb <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ans <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> subProb <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 记录本轮答案，下标就是凑够当前硬币的最少枚次数</span>
  memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> ans<span class="token punctuation">;</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="动态规划-1" tabindex="-1"><a class="header-anchor" href="#动态规划-1"><span>动态规划</span></a></h4><p>如果我们有面值为 1 元、3 元和 5 元的硬币若干枚，如何用最少的硬币凑够 11 元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如 1 元换成 2 元的时候)</p><p>如何用最少的硬币凑够i元（i &lt; 11）？ 两个原因：</p><ul><li>当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论</li><li>这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题（规模变小后的问题其实是原问题的子问题）</li></ul><p>当 i = 0，即需要多少个硬币来凑够 0 元。 由于 1，3，5 都大于 0，即没有比 0 小的币值，因此凑够 0 元最少需要 0 个硬币。这时候可以用一个 <strong>标记</strong> 来表示「凑够 0 元最少需要 0 个硬币」。</p><p>那么， 我们用 <code>d(i) = j</code> 来表示凑够 i 元最少需要 j 个硬币。于是我们已经得到了 <code>d(0) = 0</code>，表示凑够 0 元最小需要 0 个硬币。</p><p>当 i = 1 时，只有面值为 1 元的硬币可用，因此我们拿起一个面值为 1 的硬币，接下来只需要凑够 0 元即可，即 <code>d(0) = 0</code>。所以有：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当 i = 2 时，仍然只有面值为 1 的硬币可用，于是我拿起一个面值为 1 的硬币，接下来我只需要再凑够 2 - 1 = 1 元即可， 所以有：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当 i = 3 时，我们能用的硬币就有两种了：1 元和 3 元。既然能用的硬币有两种，于是就有两种方案。如果我拿了一个 1 元的硬币，我的目标就变为了： 凑够 3 - 1 = 2 元需要的最少硬币数量。即</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个方案说的是，我拿 3 个 1 元的硬币；第二种方案是我拿起一个 3 元的硬币，我的目标就变成：凑够 3 - 3 = 0元需要的最少硬币数量。即</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个方案说的是，我拿 1 个 3 元的硬币。</p><p>这两种方案哪种更优呢？题目要求使用用最少的硬币数量来凑够 3 元的。所以，选择 <code>d(3) = 1</code>，所以我们得到了 <strong>转移状态方程</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从以上的文字中， 我们要得到动态规划里非常重要的两个概念：<strong>状态</strong> 和 <strong>状态转移方程</strong>。</p><p>上文中 d(i) 表示凑够 i 元需要的最少硬币数量，我们将它定义为该问题的 <strong>状态</strong>， 这个状态是怎么找出来的呢？要根据子问题定义状态，找到子问题，状态也就浮出水面了。最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够 11 元最少需要多少个硬币。</p><p>那状态转移方程是什么呢？既然我们用 d(i) 表示状态，那么状态转移方程应该包含了状态 d(i)，上文中包含状态 d(i) 的方程是：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>于是它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span>i <span class="token operator">-</span> vj<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 其中 i-vj &gt;= 0，vj 表示第 j 个硬币的面值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以最终代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 内层 for 在求所有子问题 + 1 的最小值</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态转移方程</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="例题实战" tabindex="-1"><a class="header-anchor" href="#例题实战"><span>例题实战</span></a></h2><h3 id="爬楼梯" tabindex="-1"><a class="header-anchor" href="#爬楼梯"><span>爬楼梯</span></a></h3><p>下面介绍先通过典型的动态规划题目总结 <strong>计算步骤</strong>，然后利用计算步骤完成动态规划的题目。</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>如 n = 2 时，有两种方法，分别是：</p><ul><li>1 阶 + 1 阶</li><li>直接 2 阶</li></ul><p>如 n = 3，有三种方法，分别是：</p><ul><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ul><h4 id="计算步骤" tabindex="-1"><a class="header-anchor" href="#计算步骤"><span>计算步骤</span></a></h4><ul><li><strong>特例确定</strong>，也就是「剪枝」，判断满足某些条件，直接返回，不需要计算，一般针对起始位置或末尾位置</li><li><strong>状态定义</strong>：定义状态的空间位置，确保动态规划有足够的空间存放子问题的解，如下题 f[i] 代表走过 i 阶需要的总方法</li><li><strong>初始状态</strong>，动态规划自底向上，所以底部（0 或者 1）至少要有一个已知的值，然后慢慢推到后面的值</li><li><strong>状态转移方程</strong>，动态规划最难的就是求解出状态转移方程，这是一种递推规律的公式</li><li><strong>返回值</strong>：确定最终的返回值</li></ul><h4 id="简单动态规划" tabindex="-1"><a class="header-anchor" href="#简单动态规划"><span>简单动态规划</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 特例</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 确定空间</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始条件</span>
  f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// -1 才是没有楼梯</span>
  f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token comment">// 转移方程</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> f<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> f<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="优化动态规划" tabindex="-1"><a class="header-anchor" href="#优化动态规划"><span>优化动态规划</span></a></h4><p>因为我们只需要 3 中状态，也就是只需要 3 种子问题的解，即 n、n - 1、n - 2，其他的不需要，所以就利用变量来替换</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> q<span class="token punctuation">;</span> 
        q <span class="token operator">=</span> r<span class="token punctuation">;</span> 
        r <span class="token operator">=</span> p <span class="token operator">+</span> q<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="最小路径和" tabindex="-1"><a class="header-anchor" href="#最小路径和"><span>最小路径和</span></a></h3><p>题目来自 <code>https://leetcode-cn.com/problems/minimum-path-sum/</code></p><p>解题思路参考：<code>https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-dong-tai-gui-hua-gui-fan-liu-c/</code></p><p><code>题目</code></p><ul><li>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小</li><li><strong>说明</strong>：每次只能向下或者向右移动一步</li></ul><p>示例 1：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 2：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：grid = [[1,2,3],[4,5,6]]
输出：12
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此题是典型的动态规划题目。</p><p>下面按动态规划的步骤进行计算：</p><p><code>特例确定</code></p><p>如果 DP 长度为 0，返回 0。</p><p><code>状态定义</code></p><p>设 DP 为大小 <code>m x n</code> 矩阵，其中 <code>dp[i][j]</code> 的值代表直到走到 (i,j) 的最小路径和。</p><p><code>初始状态</code></p><p>DP 初始化即可，不需要赋初始值。</p><p><code>状态转移方程</code></p><p>题目要求，只能向右或向下走，换句话说，当前单元格 (i, j) 只能从左方单元格 (i−1, j) 或上方单元格 (i, j−1) 走到，因此只需要考虑矩阵左边界和上边界。</p><p>走到当前单元格 (i, j) 的最小路径和 =「从左方单元格 (i-1, j) 与从上方单元格 (i, j−1) 走来的两个最小路径和中较小的」 + 当前单元格值 <code>dp[i][j]</code> 。具体分为以下 3 种情况：</p><ul><li>矩阵的第一列进行求和，然后覆盖原来的值。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>矩阵的第一行进行求和，然后覆盖原来的值。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><strong>当左边和上边都不是矩阵边界时</strong>： 即当 i、j 不等于 0 时，有</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>返回值</code></p><p>返回 DP 矩阵右下角值，即走到终点的最小路径和。</p><p><code>复杂度分析</code></p><p>时间复杂度 O(M x N)：遍历整个 grid 矩阵元素。</p><p>空间复杂度 O(1)：直接修改原矩阵，不使用额外空间。</p><p>grid 代表 DP</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> high <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> width <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>width <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 先将矩阵 [0] 的左右进行叠加</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> grid<span class="token punctuation">[</span>high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="不同路径" tabindex="-1"><a class="header-anchor" href="#不同路径"><span>不同路径</span></a></h3><p>题目来自：<code>https://leetcode-cn.com/problems/unique-paths/</code></p><p><code>题目</code></p><ul><li>一个机器人位于一个 m x n 网格的左上角</li><li>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，即 m x n 的终点（对角线的末尾）</li><li>问总共有多少条不同的路径？</li></ul><p>下面按动态规划的步骤进行计算：</p><p><code>特例确定</code></p><p>无特例。</p><p><code>初始状态</code></p><p>DP 初始化即可，不需要赋初始值。</p><p><code>状态定义</code></p><p>设 m x n 矩阵有 <code>dp[i][j]</code>，其中 i 代表矩阵的第 i 行，j 代表第 j 列。</p><p><code>状态转移方程</code></p><p>规律：</p><ul><li>如果位置处于第一行或者第一列，则总路径 = 1</li><li>不在第一行或者第一列，则某个位置的总路径 = 它上面位置的总路径 + 它左侧位置的总路径</li></ul><p>状态转移方程为：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>返回值</code></p><p>返回 DP 矩阵右下角值，即走到终点的总路径和。</p><p><code>复杂度分析</code></p><p>时间复杂度 O(m x n)：遍历整个 DP 矩阵元素。</p><p>空间复杂度 O(n)：直接修改原矩阵，不使用额外空间。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 起始点为 0，如果在起始点的左侧或者右侧，那么就只有一条路径</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 每条路径的次数都是从上方的路径和左侧的路径相加而得到，具体画图</span>
      <span class="token keyword">else</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回最后一个元素，数组从 0 开始</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h2><p>适合用动态规划来解决的问题，都具有下面三个特点：最优化原理、最优化原理、有重叠子问题。</p><p>如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。某阶段状态（定义的新子问题）一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与其以前的状态有关。子问题之间是不独立的（分治法是独立的），一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。</p><h2 id="算法局限" tabindex="-1"><a class="header-anchor" href="#算法局限"><span>算法局限</span></a></h2><p>动态规划对于解决多阶段决策问题的效果是明显的，但是动态规划也有一定的局限性。首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；另外当变量的维数增大时，总的计算量及存贮量急剧增大。因而，受计算机的存贮量及计算速度的限制，当今的计算机仍不能用动态规划方法来解决较大规模的问题，这就是「维数障碍」。</p><p>动态规划大部分都是 <strong>空间换时间</strong>，因为动态规划需要一个 DP 来存已经计算的子问题的解，所以需要利用大量的空间来存解值，但是在时间上就很快找出该解值，不需要重新求解值。</p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/shaohui-jin/shaohui-jin.github.io/edit/main/src/zh/算法/动态规划算法.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1051131737@qq.com">shaohui_jin</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link nav-link prev" href="/my-blog/Algorithm/Dichotomy/" aria-label="二分查找理论"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->二分查找理论</div></a><a class="route-link nav-link next" href="/my-blog/Algorithm/PriorityTraversal/" aria-label="优先遍历算法"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">优先遍历算法<!----></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2025 石怜安 </div></footer></div><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/my-blog/assets/app-EVybbKqM.js" defer></script>
  </body>
</html>
