---
headerDepth: 3
---

### ES6新特性
1. 块级作用域（let const）
> 不存在变量提升、存在暂时性死区、块级作用域、不能在同一个作用域重复声明
2. 新增语法糖 class
3. 基本数据类型 symbol
4. 新增解构赋值
5. 新增箭头函数
不能作为构造函数使用，不能使用new、箭头函数没有原型、箭头函数没有arguments、箭头函数不能使用call、bind、apply改变this的指向、this指向 外层第一个函数的this
6. 新增了函数参数的默认值
7. 数组新增了api
8. 对象数组新增了拓展运算符
console.log(1, ...[2, 3, 4], 5)
9. Promise
10. 模块化 import export
11. 新增set(不重复) map(key类型不受限制)数据结构
12. 新增generator
```js
function* xxfn(){
  yield 'a';
  yield 'b';
  yield 'c';
  return 'd end...'
}
var _xxfn = xxfn()

//第一个yield语句
console.log(_xxfn.next())//{value: 'a', done: false}
```

### 继承

1. 原型链的继承

让一个构造函数的原型是另一个类型的实例，那么这个构造函数new出来的实例就具有该实例的属性

`优点`：写法方便简洁，容易理解

`缺点`： 对象实例共享所有继承的属性和方法，无法向父类构造函数传值

2. 借用构造函数继承

在子类型构造函数的内部调用父类型的构造函数，使用 apply或call将父对象的构造函数绑定在子对象上

`优点`： 解决了原型链实现继承的不能传参的问题以及父类的原型共享问题

`缺点`：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言是不可见的

3. 组合继承

使用原型链实现对原型属性和方法的继承
通过借用构造函数进来实现对实例属性的继承
既通过在原型上定义方法，实现了函数复用，又能保证每个实例都有自己的属性

### Es6 的 class

Class通过extends关键字来实现继承，其本质是
1. 先创造出父类的this对象
2. 然后用子类的构造函数修改this
3. 子类的构造函数中必须调用super方法，且只有在调用了super之后才能使用this，因为子类的this对象是继承父类的this对象，然后对其进行加工，而super方法表示的是父类的构造函数，用来新建父类的this对象

### ES6 的 Promise

1. 解决了回调地狱的问题
2. 自身有all、reject、resolve、race方法
3. 原型上有then、catch方法
4. 把异步队列化
5. 三种状态：pending 初始状态、rejected 操作失败、fulfilled 操作成功
