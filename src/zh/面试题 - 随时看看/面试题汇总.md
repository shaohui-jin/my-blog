---
title: 面试题汇总
lang: zh-CN
date: 2024-05-05 16:59:31
permalink: /InterviewQuestion/
headerDepth: 5
---

## CSS

### rem、px、em 字体大小

> **px**是相对于显示器屏幕分辨率的存在，是一个 **绝对单位**，不随页面缩放而变化。计算方式为：`1px = 1/96英寸`。
> 
> **em**是相对于 **元素自身** 的字体大小的存在，如果元素没有设置字体大小，则相对于父元素的字体大小。
> 
> **rem**是相对于 **根元素（即html元素）** 的字体大小的存在，它不受 **元素字体大小** 和 **父元素字体大小** 的影响，只受根元素字体大小的影响。

###  CSS 选择器特性: 继承性、 层叠性、优先级

> **继承性**
> - **字体系列** 属性
> - **文本相关** 属性
> - **元素可见性** 属性
> - **列表相关** 属性
> - **表格相关** 属性
> - **其他** 属性，如：cursor **（光标样式）**、direction **（文本方向）**、unicode-bidi **（双向文本处理）**、outline **（轮廓线）**、quotes **（引用样式）**、pointer-events **（指针事件）**。
>
> 优先级
> 写 CSS 样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式
> 其中 **!important** > **行内样式** > **id** > **类/伪类/属性** > **标签** > **全局选择器** > **浏览器默认样式**

### transform、 translate、transition

> **Transform 变形**， rotate旋转、skew扭曲、scale缩放、translate移动、matrix 2D转换方法
>
> **Translate 平移**
>
> **Transition 过渡**， property运动 duration持续时间 timing-function delay延迟

### BFC的布局规则

> 1. 内部的 box 会在垂直方向上，一个接一个的放置
> 2. box 垂直方向 的距离由 margin 决定，属于同一个BFC的两个相邻 box 的 margin 会发生重叠
> 3. BFC 的区域不会与浮动元素区域重叠
> 4. BFC 就是页面上一个独立容器，容器内的子元素不会影响到外面的元素
> 5. 计算 BFC 的高度时，浮动元素也参与计算

## JS

### 数据类型

> 基本数据类型： number，bigInt， boolean， null，undefined，string，symbol，
> 基本数据类型保存在栈内存中，保存的就是一个具体的值
>
> 引用数据类型：object (后面不算)     date，RegExp，function，array，
> 保存在堆内存当中，声明一个引用类型的变量，他保存的就是应用数据类型的地址
> 
> 假如声明两个引用类型同时指向一个地址的时候，修改其中一个那么另一个也发生改变

### 类型转换优先级

> **[Symbol.toPrimitive] -> valueOf -> toString**

```js
let a = {}
console.log(a + 2) // [object Object]2

a.toString = () => {
  return 'toString'
}
console.log(a + 2) // toString2

a.valueOf = () => {
  return 'valueOf'
}
console.log(a + 2) // valueOf2

a[Symbol.toPrimitive] = () => {
  return '[Symbol.toPrimitive]'
}
console.log(a + 2) // [Symbol.toPrimitive]2
```

### 闭包

<!-- @include: @src/zh/友情推广/JavaScript/闭包以及内存泄漏原因.md#info -->

### 作用域

`描述`：作用域是指在运行时，代码中的某些特定部分中变量、函数和对象的可访问性

作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。

ES6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域。

ES6 提出了 **块级作用域** 所声明的变量在指定块的作用域外无法被访问。

> **高级描述：** 执行上下文中的词法环境

### 作用域链

由词法环境中的 **outerEnv指针** 形成的链条

当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找。

如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。

这种一层一层的关系，就是 作用域链 。

> **高级描述：** 词法环境形成的链条

### Typeof、instanceof、constructor、Object.prototype.toString.call

```js 
// Typeof
typeof 1;
// 'number' 只能检测基本数据类型

// Instanceof
[] instanceof Array;
// true 只能检测引用数据类型

// Constructor
('123').constructor === String; 
// true 基本能够检测基本类型和引用类型，但是如果声明构造函数，并把它的原型换指向Array，就不对了

// Object.prototype.toString.call  
Object.prototype.toString.call(2)
// '[object Number]' 能够完全检测基本类型和引用类型
```

### 事件委托

> 事件委托又叫事件代理，原理是利用事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上，
> 
> 如果子元素阻止了事件冒泡(Event.stopPropagation)，那么委托也就不成立
> 
``` js 
addEventListener('click', () => {}, true || false )  // True 事件捕获， false 事件冒泡
```

### this 指向

> 全局对象中的 this 指向 window

```js
console.dir(this) // Window
```

> 全局作用域 或 普通函数的 this 指向 window

```js
const fn = () => {
  console.dir(this) // Window
}
fn()
```

> 全局作用域 或 普通函数的 this 指向 window

```js
String.prototype.fn = function() {
  console.log(this)
}
'123'.fn() // String {'123'}
```

> New 关键字改变了 this 指向 (二义性导致的)

```js
function aa() {
  console.dir(this)
}
aa(); // Window
const a = new aa(); // aa
```

> apply，call，bind 改变 this 的指向（非箭头函数）

```js
function a() {
  console.log(this)
}
a(); // Window
a.apply("123") // String {'123'}
a.call(123) // Number {123}
a.bind(1234)() // Number {1234}
```

> 箭头函数中的this，它在定义的时候就已经确定好了，如果外层有函数，则是外层函数的this，没有的话就是window

```js
const fn = function () {
  console.log(this)
  const fn = function () {
    console.log('内部非箭头函数', this)
  }
  fn()
  const fn1 = () => {
    console.log('内部箭头函数', this)
  }
  fn1()
}
fn()
// Window
// 内部非箭头函数 Window
// 内部箭头函数 Window

fn.bind(123)()
// 123
// 内部非箭头函数 Window
// 内部箭头函数 123
```

> 匿名函数中的this永远指向window，匿名函数的执行环境具有全局性，因此指向window


### new 操作符做了什么

```js
function newFun(fn, ...args) {
  // 1.先创建一个空对象
  let newObj = {}
  // 2.把空对象和构造函数通过原型链进行链接
  newObj.__proto__ = fn.prototype
  // 3.把构造函数的this绑定到新的空对象上
  const result = fn.apply(newObj, args)
  // 4.根据构造函数返回的类型进行判断，如果是引用数据类型，则返回这个引用类型，如果是值类型，则返回对象
  return result instanceof Object ? result : newObj
}
```

### [浏览器渲染原理](/Promotion/JavaScript/BrowserRenderingPrinciples/)

<!-- @include: @src/zh/友情推广/JavaScript/浏览器/浏览器渲染原理.md#info -->

### [事件循环](/Promotion/JavaScript/BrowserProcessModel/)

<!-- @include: @src/zh/友情推广/JavaScript/浏览器/浏览器进程模型.md#info -->

### setTimeout最小执行时间

> HTML规定最小时间为4ms

### setInterval最小执行时间

> HTML规定最小时间为10ms


## ES6

### ES6新特性
1. 块级作用域（let const）
> 不存在变量提升、存在暂时性死区、块级作用域、不能在同一个作用域重复声明
2. 新增语法糖 class
3. 基本数据类型 symbol
4. 新增解构赋值
5. 新增箭头函数
不能作为构造函数使用，不能使用new、箭头函数没有原型、箭头函数没有arguments、箭头函数不能使用call、bind、apply改变this的指向、this指向 外层第一个函数的this
6. 新增了函数参数的默认值
7. 数组新增了api
8. 对象数组新增了拓展运算符
console.log(1, ...[2, 3, 4], 5)
9. Promise
10. 模块化 import export
11. 新增set(不重复) map(key类型不受限制)数据结构
12. 新增generator
```js
function* xxfn(){
  yield 'a';
  yield 'b';
  yield 'c';
  return 'd end...'
}
var _xxfn = xxfn()

//第一个yield语句
console.log(_xxfn.next())//{value: 'a', done: false}
```

### 继承

1. 原型链的继承

让一个构造函数的原型是另一个类型的实例，那么这个构造函数new出来的实例就具有该实例的属性

`优点`：写法方便简洁，容易理解

`缺点`： 对象实例共享所有继承的属性和方法，无法向父类构造函数传值

2. 借用构造函数继承

在子类型构造函数的内部调用父类型的构造函数，使用 apply或call将父对象的构造函数绑定在子对象上

`优点`： 解决了原型链实现继承的不能传参的问题以及父类的原型共享问题

`缺点`：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言是不可见的

3. 组合继承

使用原型链实现对原型属性和方法的继承
通过借用构造函数进来实现对实例属性的继承
既通过在原型上定义方法，实现了函数复用，又能保证每个实例都有自己的属性


### Es6的 class

Class通过extends关键字来实现继承，其本质是
1. 先创造出父类的this对象
2. 然后用子类的构造函数修改this
3. 子类的构造函数中必须调用super方法，且只有在调用了super之后才能使用this，因为子类的this对象是继承父类的this对象，然后对其进行加工，而super方法表示的是父类的构造函数，用来新建父类的this对象




### 为什么要虚拟DOM

1. 框架设计： 渲染页面运行render函数，组件化开发时，属性改变时只能全量渲染，直接操作DOM代价过高，使用虚拟DOM代替
2. 跨平台：除了浏览器环境不存在dom，打包其他环境的时候可以用虚拟dom坐中间转换

## 网络

### ajax

<!-- @include: @src/zh/友情推广/JavaScript/网络/AJAX - XHR与Fetch.md#info -->

### preload、prefetch、async、defer的区别

> preload 和 prefetch：用于资源提前加载，分别适用当前页面和未来可能需要的资源。
>
> async 和 defer：用于控制脚本的加载与执行时机，async最适合独立脚本，defer适合需要按顺序执行且依赖DOM的脚本。

#### Preload

- **功能**：<link rel="preload">用于告诉浏览器在页面加载过程中需要高优先级加载的资源。
- **应用场景**：适用于当前页面必需而非即时加载的资源，如字体、关键图片和重要的CSS/JS文件。
- **优点**：提高页面关键资源的加载速度。
- **限制**：因为是高优先级下载，如果网络资源有限，可能会导致其他资源的加载延迟。
- **浏览器行为**：浏览器在解析HTML时并行下载指定的资源。

#### Prefetch

- **功能**：<link rel="prefetch">用于告诉浏览器资源之后可能会在未来使用，因此可以在空闲时间提前下载。
- **应用场景**：适合异步加载的资源或下一次导航可能需要的资源，如页面的下一步内容。
- **优点**：利用浏览器空闲时间，提升未来页面导航的速度。
- **限制**：优先级低，可能会被中断以满足当前页的资源加载。
- **浏览器行为**：在页面空闲时和带宽允许时下载资源，不会阻塞页面的当前加载。

#### Async

- **功能**：async用于异步加载JavaScript，脚本下载完成后立即执行，而不阻塞文档的解析。
- **应用场景**：适合不依赖于DOM结构的独立脚本，如统计和广告跟踪。
- **优点**：尽早下载并执行脚本，而不阻塞解析，提高页面加载速度。
- **限制**：脚本执行顺序无法保证，可能导致脚本依赖关系错乱。
- **浏览器行为**：脚本下载并解析其他HTML文档元素，下载完成后立即执行。

#### Defer

- **功能**：defer用于延迟执行JavaScript，直到HTML解析完毕之后再执行。
- **应用场景**：适合依赖DOM结构的脚本，如在文档加载完成后操作DOM的脚本。
- **优点**：保证脚本按顺序执行，并且不阻塞HTML解析。
- **限制**：需要解析完成后执行。
- **浏览器行为**：按顺序下载脚本文件，HTML解析完成后按顺序执行。


### 同源与跨域

#### 同源策略限制了什么

1. DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作
2. 数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据
3. 网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点

#### 跨域三要素

浏览器限制：即浏览器对跨域行为进行检测和阻止
触发跨域的三要素之一：协议、域名、端口
发起的是xhr请求：即XMLHttpRequest

#### 如何解决跨域

被调用方解决跨域设置 访问控制允许来源
response.addHeader(‘Access-Control-Allow-Origin’,’*’ )
调用方使用Nginx 代理调用方请求，目的是为了和被调用方的域名端口保持一致
jsonp


#### a.com -> b.com 跨域发生在一步

### get请求跨域吗

### 什么时候会发送预检请求

### 网络策略

#### CORS 跨源资源共享


#### CSP 内容安全策略

同源策略是期望让我们的页面引用的资源都来自一个源，对于不是同源的文件，我们默认就是不安全的
CSP的核心思想就是让服务器决定浏览器可以加载那些资源，让服务器决定浏览器是否能够执行加载的JS代码。
Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com


## Vue3

### ref 和 reactive的用法
### reactive的响应式

## React

### 类组件 和 函数组件 的区别
### useState 和 useRef
### useLayoutEffect


## 代码测试 

## 灵活

### 长列表问题

1. 帧动画加载
2. 冻结数组
3. 触底加载
4. 文档碎片Fragment
